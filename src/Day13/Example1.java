package Day13;

public class Example1 {
    public static void main(String[] args) {
        /*
        - 클래스 멤버 : 1. 멤버변수, 2. 생성자, 3. 메소드
        [ 상속 ]
        1. 정의 : (상위)클래스로부터 (하위)클래스에게 (멤버변수/메소드를)물려주는 행위
        2. 목적 : 빠른 개발, 한번 만들어둔 클래스를 재사용한다.
        3. 키워드 : extends
        4. 장점
            1) 유지보수
            2) 계층표현 가능
            3) 재사용
            4) **다형성**
        5. 사용법 : class 하위클래스명 extends 상위클래스명{ }
        6. 주의할점
            1) 상위클래스는 1개만 존재할 수 있다.
            2) 하위클래스가 상위클래스를 선택한다.(자식이 부모를 선택)
        7. 다형성 : 같은 모양이지만, 다양한 형식/타입을 갖는 성질
            1) 자동 타입변환
                (1) 기본 타입 : byte short int long float double char boolean
                    byte -> short -> int -> long -> float -> double
                (2) 참조 타입
                    하위클래스 타입에서 상위클래스 타입으로 자동 변환
                    -> 상속 관계에서만 가능
            2) 강제 타입변환 : (변환할타입) 값
                (1) 기본 타입
                    double -> float -> long -> int -> short -> byte
                (2) 참조 타입
                    상위클래스 타입에서 하위클래스 타입으로 강제 변환
                    -> 상속 관계에서만 가능 + 객체의 최초 타입이 하위클래스
            3) 컴퓨터 내부의 다형성 이해
                (1) 닭 객체 생성 시, 총 3개의 객체 생성(닭/조류/동물)
                    -> 하위클래스 객체로 생성하면, 강제 타입변환이 가능한 이유 -> 하위클래스 객체로 생성하면 상위클래스가 모두 생성됨
                (2) 참새 객체 생성 시, 총 3개의 객체 생성(참새/조류/동물)
                    -> 따라서 형제클래스 간 변환은 불가능함 -> 서로를 모름
                (3) 조류 객체 생성 시, 총 2개의 객체 생성(조류/동물)
                    -> 조류 객체는 닭이 될 수 없다. -> 닭 객체가 생성되지않아서 누군지 모름
        */
        // [1] 동물 클래스로 객체 1개 생성
        동물 animal = new 동물();
        animal.name = "강아지";
        animal.show();          // '강아지' 출력

        // [2] 조류 클래스로 객체 1개 생성
        조류 bird = new 조류();
        bird.name = "비둘기";    // 조류 클래스에 존재하지않는 멤버변수 사용 가능
        bird.show();            // '비둘기' 출력

        // [3] 참새 클래스로 객체 1개 생성
        참새 sparrow = new 참새();
        sparrow.name = "참새";   // 상위클래스의 상위클래스로부터 멤버변수/메소드 상속 가능
        sparrow.show();         // '참새' 출력

        // [4] 닭 클래스로 객체 1개 생성
        닭 chicken = new 닭();
        chicken.name = "닭";
        chicken.show();         // '닭' 출력

        // [ 다형성 ]
        // (1) 참새(객체)의 형식/타입/클래스를 조류로 변경
        조류 bird2 = sparrow;

        // (2) 참새(객체)의 클래스를 동물로 변경
        동물 animal2 = sparrow;

        // (3) 동물(객체)의 클래스를 참새로 변경
        //     -> 부모클래스는 자식클래스를 모른다.
     // 참새 sparrow2 = animal;   오류 발생
     // 조류 bird3 = animal;      오류 발생

        // (4) 상위클래스에서 하위클래스로 변경 조건
        //     -> 객체의 최초 타입이 중요
        // (4-1) 닭클래스로 선언된 객체는 닭 -> 동물 -> 닭 (가능)
        닭 닭1 = new 닭();     // 닭클래스로 선언된 객체
        동물 동물1 = 닭1;       // 상위클래스로 변환 : 자동 타입변환
        닭 닭2 = (닭)동물1;     // 하위클래스로 변환 : 강제 타입변환

        // (5) 형제클래스 간 타입 변환 절대 불가능
     // 참새 참새1 = 닭2;


    } // main end
} // class end
// (1) 동물 클래스
class 동물{
    String name;        // 멤버변수 선언
    void show(){        // 메소드 생성
        System.out.println("이름 : " + this.name );
    } // func end
} // class
// (2) 조류 클래스 : 동물 클래스로부터 상속받기
class 조류 extends 동물{ }
// (3) 참새 클래스 : 조류 클래스로부터 상속받기
class 참새 extends 조류{ }
// (4) 닭 클래스 : 조류 클래스로부터 상속받기
class 닭 extends 조류{ }